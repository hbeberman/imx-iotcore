Manufacturing
==============

This document describes the build configuration for manufacturing images along with the boot flow to do device provisioning on first boot.


## Configuration

### SRKH fusing
In order to enable High Assurance Boot, the Super Root Key Hash (SRKH) must be fused on your platform.

To obtain this value SPL pulls it out of the Flattened Device Tree (FDT) built into SPL.
During the build of SPL, the Common.mk buildscript will retrieve the SRKH values from the file defined by SRKH_FUSE_BIN near the top of the file. This file is generated by NXP's Code Signing Tool (CST) and contains the SRKH values corresponding to the keys allowed for High Assurance Boot.

Fusing the SRKH writes the values into OCOTP_SRK0 through OCOTP_SRK7.

The flow additionally sets the SEC_CONFIG fuse to 1, putting the paltform into Closed state on boot, meaning the Boot ROM will only start execution of loaded software if it's signature matches the keys allowed in the SRKH.

### MAC address fusing
On the i.MX6 Quad the MAC address is split between two fuses: OCOTP_MAC0, and OCOTP_MAC1

`spl_board_manufacture` sends the string "MFG:reqmac\n" out the serial line then awaits a response from a remote host. The host must respond to the MFG:reqmac request by sending the value to be fused into OCOTP_MAC0, then the value for OCOTP_MAC1 in sequence.

### U-Boot Configuration
The following two settings must be added to your U-Boot config to blow SRKH and MAC address fuses during manufacture. These also require a board specific version of spl_board_manufacture.

CONFIG_SPL_BOARD_MANUFACTURE=y
With this configuration set, U-Boot SPL will call the board specific function `spl_board_manufacture` from inside `board_init_r`. In the reference flow `spl_board_manufacture` is defined in `mx6cuboxi.c`

CONFIG_MANUFACTURE_FUSES=y
With this configuration set,`spl_board_manufacture` will actually perform permanent fusing operations on the SoC. Can be left disabled while testing the flow on boards that have already been fused.

### OP-TEE RPMB key generation and write once

When the fTPM and AuthVars TAs are running in OP-TEE they make requests to securely store nonvolatile data in the RPMB paritition of an onboard eMMC. In order to handle these writes and reads OP-TEE submits them to the OP-TEE supplicant who runs the storage driver on it's behalf. In the case of this BSP the OP-TEE suplicant RPMB transactions is UEFI, then once Windows has loaded the imxusdhc driver.

The RPMB relies on a write-once RPMB key that is used to encyrpt data retrieved from the eMMC, and to decrypt data sent to the eMMC. In order to program this value, OP-TEE submits a request to the supplicant and sends the key in plaintext to normal-world memory for the supplicant to then burn into the eMMC. This is an operation that *MUST* only be done in the factory, otherwise an attacker could swap eMMCs then intercept the same key computed in OP-TEE and use it to access secure data on the original eMMC.

In order to ensure this key write operation only occurs once a general purpose fuse is blown inside of OP-TEE after an eMMC is successfully keyed. The entry point of the key programming flow checks to see if the fuse is blown, and if so it will refuse to send the plaintext key to the supplicant again. In normal operation this path will not be hit more than once, as the key write function only occurs when OP-TEE detects that an eMMC is unkeyed.

The platform specific functions that must be defined are the following:
```C
TEE_Result tee_otp_check_rpmb_key_write_lock(void)
// Checks the RPMB key write-once fuse
// Returns TEE_ERROR_BAD_STATE if the fuse that forbids RPMB key writes is blown. Will cause an OP-TEE kernel panic on purpose.
// Returns TEE_SUCCESS if the fuse that forbids RPMB key writs is not blown.


TEE_Result tee_otp_set_rpmb_key_write_lock(void)
// Upon verification that the RPMB key was programmed successfully blows the RPMB key write-once fuse.
// Returns TEE_ERROR_BAD_STATE if the fuse blow operation fails. Will cause an OP-TEE kernel panic on purpose.
// Returns TEE_SUCCESS if the fuse blow operation succeeds.
```
The default implementations return TEE_SUCCESS so they're no-ops on platforms without explicit support.

### fTPM Endorsement Key Certificate

The fTPM Endorsement Key Certificate is the public key that can be used verify the authenticity of a TPM. In order to trust this EK Cert it must be extracted in the factory and must be stored by the OEM. The OEM then cross signs the EK Cert to assert that they trust it. This cross signed certificate should be persisted back onto the platform for convenience, but must also be avalable externally for future reference in-case the non-volatile storage on the device is reset.

The UEFI DXE driver defined in Provisioning.c opens a handle to the fTPM driver and requests the Endorsement Key Certificate. It signals the manufacturing PC that it's about to send the EK Cert by sending the string "MFG:ekcertstart\n" over serial, it then sends the EK Cert over serial byte by byte in hexadecimal. Once the certificate is complete the device sends "MFG:ekcertend\n" to signal to the manufacturing PC that the certificate is complete.

In anticipation of a cross signed cert, the device sends "MFG:devicecert\n" to the manufacturing host, then reads 4 bytes from serial to determine the length of buffer required for the cross signed certificate. The device then reads that many bytes from serial and writes the "ManufacturerDeviceCert" UEFI variable with this certificate buffer.

### SMBIOS Customizations

Some manufacturers may want to customize specific fields in the SMBIOS table with per-device values.

The SMBIOS tables are constructed during boot in [imx-edk2-platforms PlatformSmbiosDxe.c](https://github.com/ms-iot/imx-edk2-platforms/blob/imx/Silicon/NXP/iMX6Pkg/Drivers/PlatformSmbiosDxe/PlatformSmbiosDxe.c). Most of the values are pulled from the Platform Configuration Database (PCD) which are static oer board configuration. Some are generated dynamically based on values in fuses or the build time of the firmware. Values can be pulled out of UEFI variables with a fallback to default values if its not set. See the usage of RetrieveSmbiosVariable in PlatformSmbiosDxe.c as a reference.

These UEFI variables can be populated by a host PC over serial from the Provisioning UEFI DXE driver.

##First Boot

1) SPL boots to spl_board_manufacture.
2) spl_board_manufacture 


## Board specific implementation

### U-Boot

U-Boot SPL is responsible for fusing the SRKH High Assurance Boot Key and the MAC address into SoC fuses.

1) Copy the section within `#ifdef CONFIG_SPL_BOARD_MANUFACTURE` from board\solidrun\mx6cuboxi\mx6cuboxi.c. This includes `struct srkfdt` and `void spl_board_manufacture()`

2) Set CONFIG_SPL_BOARD_MANUFACTURE in your board defconfig

3) Build the firmware, deploy it to the device and attempt to boot. This firmware will not blow any of the fuses, it will just print out what it would blow. This can be used to verify that the SRKH and MAC addresses are correct before commiting them to the platform.

4) Once you've verified that the values are correct, set CONFIG_MANUFACTURE_FUSES in your board defconfig so that spl_board_manufacture will blow the SRKH and MAC fuses.

### OP-TEE

The changes in OP-TEE are responsible for making sure the SoC will only ever provision a single eMMC RPMB with its secret key.

1) Add CFG_FSL_SEC=y to your OP-TEE flags in your board makefile. [Example Makefile](build\firmware\HummingBoardEdge_iMX6Q_2GB\Makefile)

2) If any portion of the GP1 or GP2 fuse words are already reserved for another use on your board then customize which fuse bit to use for the RPMB write lock. Open `core/drivers/fsl_sec/hw_key_blob.c` and modify both `RPMB_KEY_WRITE_LOCK_FUSE_BITS` and `RPMB_KEY_WRITE_LOCK_FUSE_WORD`

3) When the fTPM tries to access the RPMB for the first time, OP-TEE will run through this flow and blow the fuse if the RPMB key write was successful. If the RPMB key is already provisioned then this flow is skipped entirely.

### UEFI

The changes in UEFI are responsible for the following:
* Loading SMBIOS values from UEFI Variables.
* Loading the Endorsement Key Certificate from the fTPM and saving it to a host computer.
* Recieving a cross-signed EK Certificate to save into UEFI Variables on the device for easy access.
* Recieving per-device SMBIOS values to save into UEFI Variables to be recalled on future boots.
* Set the DeviceProvisioned variable so subsequent boots will not run this driver.

1) Open `Silicon\NXP\iMX6Pkg\Drivers\PlatformSmbiosDxe\PlatformSmbiosDxe.c` and observe where RetrieveSmbiosVariable is called. This function tries to open a variable from UEFI variables and returns an allocated buffer with the value if successful. The table creation functions can be updated to pull additional values from UEFI variables. (`FakeSMBIOSDataInVolatileStorage` and `StoreSmbiosVariable` are used to prepare these values for retrieval until non-volatile UEFI variables are ready.)

2) Open `Silicon\NXP\iMXPlatformPkg\Drivers\Provisioning\Provisioning.inf` and note that the driver is configured to have a depex on gEfiTcg2ProtocolGuid so that the driver is forced to load after the fTPM is available.

3) Open `Silicon\NXP\iMXPlatformPkg\Drivers\Provisioning\Provisioning.c` and observe the `ProvisioningInitialize` function. This function calls each of the functions responsible for UEFI provisioning. You can extend `RecieveSmbiosValues` with additional RecieveBuffer and SetVariable calls to save more device-specific values from the manufacturing host.

### imx-iotcore

The imx-iotcore repository contains the makefile changes required to support SPL SRKH fusing, along with a simple Python script to demonstrate the role of a manufacturing host.


1) Open `build\firmware\Common.mk` and observe the following section under `$(SPL_PUB_KEYED): $(UBOOT_OPTEE_FIT)`
```makefile
	dtc -I dtb -O dts -o temp-dt-spl.dts dt-spl.dtb
	echo "/ { srkh { srkh-fuse = <" >> temp-dt-spl.dts
	hexdump -e '/4 "0x"' -e '/4 "%X""\n"' < $(SRKH_FUSE_BIN) >> temp-dt-spl.dts
	echo ">; }; };" >> temp-dt-spl.dts
	dtc -I dts -O dtb -o dt-spl.dtb temp-dt-spl.dts
	rm -f temp-dt-spl.dts
```
This section dumps the SPL device tree to a sources file, appends a new srkh section with the variable srkh-fuse, then fills srkh-fuse with the values output by NXP's Code Signing Tool when generating a set of High Assurance Boot Keys. It then recompiles the device tree, replaces the original, and deletes the intermediate device tree source file. This is the value used by SPL to fuse the SRKH onto the SoC and enable High Assurance Boot.

2) Open `provision.py` and customize `ser = serial.Serial('COM4', 115200)` to match the COM port for your serial connection to the device. Note that the script is hardcoded to send some set values for MAC address and Serial Number.

3) Run `pip install PySerial` in CMD to install the serial library.

4) Run `python provision.py` to start the provisioning host.

5) Boot a connected device running the manufacturing firmware.

Features missing from a complete implementation:
* A connection to an OEM database to assign per-device information such as MAC Addresses, Serial numbers, and other SMBIOS customizations.
* A connection to an OEM database to save the Endorsement Key Certificates
* Host-side cross-signing of the Endorsement Key Certificate to prove that the TPM is trusted by the OEM.
* Factory integration to power off the device and start the next on successful provisioning or to raise an alert on failure.
* Saving Secure Boot UEFI Variables to the device to enable secure boot. Easy to add but the signed boot critical drivers are not ready yet.